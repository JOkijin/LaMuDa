#!/usr/bin/env python3 
# -*- coding: utf-8 -*-
"""
Varjo XR-4æ¥å£æ¨¡å— - å®ç°VRä»¿çœŸæ ¸å¿ƒåŠŸèƒ½ 
åŠŸèƒ½è¯´æ˜ï¼š
1. åŠ¨æ€è§†åœºè°ƒèŠ‚ç®—æ³•å®ç° 
2. çœ¼åŠ¨è¿½è¸ªä¼˜åŒ–æ¸²æŸ“ 
3. ç”Ÿç†çŠ¶æ€ç›‘æµ‹ä¸æ¨¡å¼åˆ‡æ¢ 
4. ç¡¬ä»¶è®¾å¤‡æ§åˆ¶æ¥å£ 
"""
 
import time 
import math 
import numpy as np 
import threading 
from typing import Tuple, Dict, Any 
 
# è™šæ‹Ÿç¡¬ä»¶æ¨¡æ‹Ÿå‚æ•°ï¼ˆå®é™…å¼€å‘éœ€æ›¿æ¢ä¸ºVarjo SDKï¼‰
XR4_CONFIG = {
    "fov_range": (87, 115),     # æ°´å¹³è§†é‡è§’èŒƒå›´(åº¦)
    "refresh_rate": 240,        # å±å¹•åˆ·æ–°ç‡(Hz)
    "eye_tracking_fps": 120,     # çœ¼åŠ¨è¿½è¸ªé‡‡æ ·ç‡ 
    "display_resolution": (2880, 2720),  # å•çœ¼åˆ†è¾¨ç‡(å®½xé«˜)
}
 
class VarjoInterface:
    """
    Varjo XR-4å¤´æ˜¾è®¾å¤‡æ§åˆ¶æ¥å£ 
    å®ç°åŸºäºVarjo XR-4ç¡¬ä»¶çš„VRä»¿çœŸæ¨¡å—æ ¸å¿ƒåŠŸèƒ½ 
    """
    
    def __init__(self, config: Dict[str, Any] = None):
        """
        åˆå§‹åŒ–Varjoè®¾å¤‡æ¥å£ 
        :param config: è®¾å¤‡é…ç½®å‚æ•°ï¼ˆé»˜è®¤ä¸ºXR4_CONFIGï¼‰
        """
        self.config  = config or XR4_CONFIG.copy() 
        self.current_fov  = 115  # å½“å‰è§†é‡è§’åº¦(é»˜è®¤æœ€å¤§å€¼)
        self.eye_position  = (0.5, 0.5)  # å½’ä¸€åŒ–çš„æ³¨è§†ç‚¹åæ ‡(x,y)
        self.user_state  = {"eeg_theta": 30, "motion": "stable"}  # ç”¨æˆ·ç”Ÿç†çŠ¶æ€ 
        self.is_running  = False 
        
        # æ¸²æŸ“è´¨é‡æ¨¡å¼ (0:æ ‡å‡†, 1:ä½å¼ºåº¦, 2:èŠ‚ç”µ)
        self.rendering_mode  = 0 
        
        # è§†åœºè°ƒèŠ‚ç®—æ³•å‚æ•° 
        self.fov_adjustment_params  = {
            "max_reduction": 20,    # æœ€å¤§è§†åœºç¼©å‡åº¦ 
            "stability_threshold": 0.1,  # è¿åŠ¨ç¨³å®šé˜ˆå€¼ 
            "theta_threshold": 40   # Î¸æ³¢é˜ˆå€¼(%)
        }
        
        # çœ¼åŠ¨è¿½è¸ªç¼“å­˜åŒº 
        self.gaze_buffer  = np.full((5,  2), 0.5)  # å­˜å‚¨æœ€è¿‘5å¸§æ³¨è§†ä½ç½® 
        
    def connect(self) -> bool:
        """è¿æ¥ç‰©ç†è®¾å¤‡ï¼Œè¿”å›è¿æ¥çŠ¶æ€"""
        # TODO: å®é™…å¼€å‘ä¸­éœ€å®ç°ä¸ç¡¬ä»¶SDKçš„è¿æ¥ 
        print(f"ğŸŸ¢ è¿æ¥Varjo XR-4: åˆ†è¾¨ç‡{self.config['display_resolution']}@{self.config['refresh_rate']}Hz") 
        self.is_running  = True 
        return True 
    
    def start_eye_tracking(self):
        """å¯åŠ¨çœ¼åŠ¨è¿½è¸ªçº¿ç¨‹"""
        if not self.is_running: 
            self.connect() 
            
        print("ğŸ‘ï¸ å¯åŠ¨çœ¼åŠ¨è¿½è¸ª...")
        # åˆ›å»ºåå°çº¿ç¨‹æ¨¡æ‹Ÿçœ¼åŠ¨æ•°æ®æ›´æ–° 
        self.eye_thread  = threading.Thread(target=self._simulate_eye_movement)
        self.eye_thread.daemon  = True 
        self.eye_thread.start() 
    
    def _simulate_eye_movement(self):
        """æ¨¡æ‹Ÿçœ¼åŠ¨è¿½è¸ªæ•°æ®æ›´æ–°ï¼ˆå®é™…åº”æ¥å…¥SDKæ•°æ®æµï¼‰"""
        while self.is_running: 
            # ç”Ÿæˆéšæœºå™ªå£°åç§» 
            x_offset = np.random.uniform(-0.1,  0.1)
            y_offset = np.random.uniform(-0.05,  0.05)
            
            # æ›´æ–°å¹¶ç¨³å®šæ³¨è§†ç‚¹ 
            new_x = max(0.1, min(0.9, self.eye_position[0]  + x_offset))
            new_y = max(0.1, min(0.9, self.eye_position[1]  + y_offset))
            self.eye_position  = (new_x, new_y)
            
            # æ›´æ–°ç¼“å­˜åŒºï¼ˆç§»åŠ¨å¹³å‡ï¼‰
            self.gaze_buffer  = np.roll(self.gaze_buffer,  1, axis=0)
            self.gaze_buffer[0]  = [new_x, new_y]
            
            time.sleep(1  / self.config["eye_tracking_fps"]) 
    
    def dynamic_fov_adjustment(self) -> float:
        """
        åŠ¨æ€è§†åœºè°ƒèŠ‚ç®—æ³• 
        åŸºäºç”¨æˆ·ç”Ÿç†çŠ¶æ€å’Œè¿åŠ¨æ•°æ®è‡ªåŠ¨ä¼˜åŒ–è§†é‡èŒƒå›´ 
        :return: ä¼˜åŒ–åçš„è§†é‡è§’åº¦ 
        """
        # 1. è®¡ç®—æ³¨è§†ç‚¹ç¨³å®šæ€§ï¼ˆä½ç½®å˜åŒ–æ–¹å·®ï¼‰
        gaze_stability = np.std(self.gaze_buffer,  axis=0).mean()
        
        # 2. ç¡®å®šè§†åœºç¼©å‡æ¯”ä¾‹ï¼ˆ0.0-1.0ï¼‰
        reduction_factor = max(0, min(1, 
            self.user_state["eeg_theta"]  / self.fov_adjustment_params["theta_threshold"]  +
            gaze_stability / self.fov_adjustment_params["stability_threshold"] 
        ))
        
        # 3. è®¡ç®—æ–°è§†é‡è§’åº¦ 
        fov_range = self.config["fov_range"] 
        max_reduction = self.fov_adjustment_params["max_reduction"] 
        target_fov = fov_range[1] - (reduction_factor * max_reduction)
        
        # 4. å¹³æ»‘è¿‡æ¸¡ï¼ˆæƒ¯æ€§æ»¤æ³¢ï¼‰
        self.current_fov  = 0.8 * self.current_fov  + 0.2 * target_fov 
        
        print(f"ğŸ”„ FOVè°ƒæ•´: {self.current_fov:.1f}Â°  | "
              f"å› å­:{reduction_factor:.2f} | "
              f"ç¨³å®š:{gaze_stability:.3f} | "
              f"Î¸æ³¢:{self.user_state['eeg_theta']}%") 
        
        return self.current_fov  
    
    def gaze_optimized_rendering(self):
        """
        çœ¼åŠ¨è¿½è¸ªä¼˜åŒ–æ¸²æŸ“ 
        åœ¨æ³¨è§†ç‚¹ä¸­å¿ƒåŒºåŸŸè¿›è¡Œé«˜è´¨é‡æ¸²æŸ“ 
        :return: æ¸²æŸ“å‚æ•°é…ç½® 
        """
        # è®¡ç®—ä¸­å¿ƒåŒºåŸŸï¼ˆç›´å¾„å å±å¹•å®½åº¦30%ï¼‰
        focus_x, focus_y = self.eye_position  
        fov_rad = math.radians(self.current_fov) 
        
        # è®¡ç®—æ¸²æŸ“è´¨é‡åˆ†å¸ƒ 
        quality_params = {
            "center_resolution": 1.0,  # ä¸­å¿ƒåŒºæœ€é«˜è´¨é‡ 
            "peripheral_reduction": 0.5,  # å‘¨è¾¹è´¨é‡é™ä½æ¯”ä¾‹ 
            "blend_radius": 0.15  # æ··åˆåŒºåŠå¾„(ç›¸å¯¹å€¼)
        }
        
        # å®é™…æ¸²æŸ“è´Ÿè½½ä¼˜åŒ–è®¡ç®— 
        optimized_load = 0.65 * quality_params["center_resolution"] + \
                         0.35 * (1 - quality_params["peripheral_reduction"])
        
        print(f"ğŸ‘ï¸ æ³¨è§†ç‚¹æ¸²æŸ“ä¼˜åŒ–: ({focus_x:.2f}, {focus_y:.2f}) | "
              f"è´Ÿè½½ç³»æ•°: {optimized_load:.2f}")
        
        return {
            "focus_position": (focus_x, focus_y),
            **quality_params,
            "gpu_load_reduction": 1 - optimized_load 
        }
    
    def update_user_state(self, eeg_theta: float, motion_data: dict):
        """
        æ›´æ–°ç”¨æˆ·ç”Ÿç†çŠ¶æ€æ•°æ® 
        :param eeg_theta: Î¸æ³¢å¼ºåº¦ç™¾åˆ†æ¯” 
        :param motion_data: è¿åŠ¨çŠ¶æ€æ•°æ® 
        """
        self.user_state["eeg_theta"]  = eeg_theta 
        self.user_state["motion"]  = self._interpret_motion(motion_data)
        
        # æ ¹æ®Î¸æ³¢å¼ºåº¦åˆ‡æ¢æ¸²æŸ“æ¨¡å¼ 
        if eeg_theta > 40 and self.rendering_mode  != 1:
            print("ğŸŸ¡ ç”¨æˆ·çœ©æ™•é£é™©! åˆ‡æ¢è‡³ä½å¼ºåº¦æ¨¡å¼")
            self.rendering_mode  = 1 
        elif eeg_theta <= 35 and self.rendering_mode  != 0:
            print("ğŸŸ¢ ç”¨æˆ·çŠ¶æ€æ¢å¤! åˆ‡æ¢è‡³æ ‡å‡†æ¨¡å¼")
            self.rendering_mode  = 0 
    
    def _interpret_motion(self, motion_data: dict) -> str:
        """åˆ†æè¿åŠ¨æ•°æ®å¹¶è¿”å›çŠ¶æ€æè¿°"""
        # ç®€åŒ–çš„è¿åŠ¨çŠ¶æ€åˆ†æï¼ˆå®é™…åº”ä½¿ç”¨ä¼ æ„Ÿå™¨èåˆç®—æ³•ï¼‰
        linear_accel = motion_data.get("linear_acceleration",  0)
        angular_vel = motion_data.get("angular_velocity",  0)
        
        if linear_accel > 2.0 or angular_vel > 45:
            return "rapid_movement"
        elif linear_accel > 0.5 or angular_vel > 15:
            return "moderate_movement"
        return "stable"
    
    def get_rendering_mode(self) -> int:
        """è·å–å½“å‰æ¸²æŸ“æ¨¡å¼"""
        return self.rendering_mode  
    
    def shutdown(self):
        """å®‰å…¨å…³é—­è®¾å¤‡è¿æ¥"""
        print("ğŸ”´ å…³é—­Varjoæ¥å£...")
        self.is_running  = False 
        if hasattr(self, 'eye_thread') and self.eye_thread.is_alive(): 
            self.eye_thread.join(timeout=1.0) 
        
    @staticmethod 
    def hardware_test():
        """è®¾å¤‡è‡ªæ£€æµç¨‹"""
        print("="*40)
        print("Varjo XR-4 ç¡¬ä»¶è‡ªæ£€:")
        print(f"â€¢ æ˜¾ç¤ºå±: {XR4_CONFIG['display_resolution']} @{XR4_CONFIG['refresh_rate']}Hz")
        print(f"â€¢ çœ¼åŠ¨è¿½è¸ª: {XR4_CONFIG['eye_tracking_fps']}fps")
        print(f"â€¢ FOVèŒƒå›´: {XR4_CONFIG['fov_range'][0]}Â°-{XR4_CONFIG['fov_range'][1]}Â°")
        print("="*40)
 
# ç¤ºä¾‹ä½¿ç”¨ 
if __name__ == "__main__":
    # 1. è®¾å¤‡åˆå§‹åŒ– 
    varjo = VarjoInterface()
    VarjoInterface.hardware_test() 
    
    if varjo.connect(): 
        # 2. å¯åŠ¨çœ¼åŠ¨è¿½è¸ª 
        varjo.start_eye_tracking() 
        
        # 3. æ¨¡æ‹Ÿç”¨æˆ·æ´»åŠ¨å¾ªç¯ 
        for t in range(15):
            # æ¨¡æ‹ŸEEGæ•°æ®å˜åŒ–ï¼ˆæ­£å¸¸->ç–²åŠ³->æ¢å¤ï¼‰
            theta_level = 30 + t * 2 if t < 7 else 46 - (t - 7) * 3 
            
            # æ›´æ–°ç”¨æˆ·çŠ¶æ€ 
            varjo.update_user_state( 
                eeg_theta=theta_level,
                motion_data={"linear_acceleration": 1.5, "angular_velocity": 20}
            )
            
            # æ‰§è¡ŒåŠ¨æ€FOVä¼˜åŒ– 
            fov = varjo.dynamic_fov_adjustment() 
            
            # æ‰§è¡Œæ³¨è§†ç‚¹æ¸²æŸ“ä¼˜åŒ– 
            render_config = varjo.gaze_optimized_rendering() 
            
            # æ ¹æ®æ¸²æŸ“æ¨¡å¼é‡‡å–ä¸åŒç­–ç•¥ 
            mode = varjo.get_rendering_mode() 
            if mode == 1:
                print("å¯ç”¨ä½å¼ºåº¦æ¸²æŸ“æ–¹æ¡ˆ...")
            
            time.sleep(1) 
        
        # 4. å…³é—­è®¾å¤‡ 
        varjo.shutdown() 