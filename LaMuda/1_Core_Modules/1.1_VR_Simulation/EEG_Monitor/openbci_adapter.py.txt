import numpy as np import pandas as pd import matplotlib.pyplot as plt from scipy import signal from threading import Thread, Event import socket import time import pylsl

class OpenBCIAdapter: def init(self, board_type='cyton', sample_rate=250, buffer_size=5): """ åˆå§‹åŒ–EEGé€‚é…å™¨

    å‚æ•°:
    board_type: è®¾å¤‡ç±»å‹ ('cyton' æˆ– 'ganglion')
    sample_rate: é‡‡æ ·ç‡ (Hz)
    buffer_size: æ•°æ®ç¼“å†²æ—¶é•¿ (ç§’)
    """
    self.board_type  = board_type 
    self.sample_rate  = sample_rate
    self.buffer_size  = buffer_size 
    
    # EEGæ•°æ®ç¼“å†²åŒº 
    self.buffer  = pd.DataFrame(columns=['timestamp', 'channel1', 'channel2', 'channel3', 'channel4'])
    
    # ç–²åŠ³æ£€æµ‹é˜ˆå€¼ 
    self.THETA_THRESHOLD = 0.40  # Î¸æ³¢åŠŸç‡å æ¯”é˜ˆå€¼
    self.CONSECUTIVE_COUNT = 5   # è¿ç»­è¶…æ ‡æ¬¡æ•°é˜ˆå€¼ 
    
    # è®¾å¤‡è¿æ¥çŠ¶æ€
    self.is_connected  = False
    self.stream_thread  = None 
    self.stop_event  = Event()
    
    # ç³»ç»Ÿé€šä¿¡é…ç½® 
    self.host  = '127.0.0.1'
    self.port  = 65432 
    self.sock  = socket.socket(socket.AF_INET,  socket.SOCK_STREAM)

def connect(self):
    """è¿æ¥OpenBCIè®¾å¤‡å¹¶å¯åŠ¨æ•°æ®æµ"""
    try:
        print(f"âš¡ æ­£åœ¨è¿æ¥OpenBCI {self.board_type.upper()} è®¾å¤‡...")
        
        # æœç´¢LSLæµ (å®é™…éƒ¨ç½²éœ€æ ¹æ®è®¾å¤‡é…ç½®è°ƒæ•´)
        streams = pylsl.resolve_stream('type',  'EEG')
        self.inlet  = pylsl.StreamInlet(streams[0])
        print("âœ… è®¾å¤‡è¿æ¥æˆåŠŸ | é‡‡æ ·ç‡:", self.inlet.info().nominal_srate()) 
        
        self.is_connected  = True 
        self._start_streaming()
        return True
    except Exception as e:
        print(f"âŒ è¿æ¥å¤±è´¥: {str(e)}")
        return False 

def _start_streaming(self):
    """å¯åŠ¨æ•°æ®æµçº¿ç¨‹"""
    self.stop_event.clear() 
    self.stream_thread  = Thread(target=self._stream_data)
    self.stream_thread.daemon  = True
    self.stream_thread.start() 
    print("ğŸ“¡ EEGæ•°æ®æµå·²å¯åŠ¨")

def _stream_data(self):
    """æŒç»­è·å–EEGæ•°æ®"""
    while not self.stop_event.is_set(): 
        # ä»LSLè·å–æ ·æœ¬ 
        sample, timestamp = self.inlet.pull_sample(timeout=1.0) 
        if sample:
            # é€šé“æ•°æ®è½¬æ¢ (æ ¹æ®å®é™…è®¾å¤‡è°ƒæ•´)
            if self.board_type  == 'cyton':
                channels = sample[:4]  # å‰4ä¸ªé€šé“ 
            else:  # ganglion 
                channels = sample
            
            # æ·»åŠ åˆ°ç¼“å†²åŒº 
            new_row = {
                'timestamp': time.time(), 
                'channel1': channels[0],
                'channel2': channels[1],
                'channel3': channels[2],
                'channel4': channels[3]
            }
            self.buffer  = self.buffer.append(new_row,  ignore_index=True)
            
            # ä¿æŒç¼“å†²åŒºå¤§å°
            if len(self.buffer)  > self.sample_rate  * self.buffer_size: 
                self.buffer  = self.buffer.iloc[1:] 
            
            # å®æ—¶åˆ†æ
            self._analyze_eeg()

def _analyze_eeg(self):
    """åˆ†æEEGç¼“å†²åŒºæ•°æ®"""
    if len(self.buffer)  < self.sample_rate  * 2:  # è‡³å°‘2ç§’æ•°æ® 
        return
    
    theta_power_ratios = []
    
    # åˆ†ææ¯ä¸ªé€šé“
    for ch in ['channel1', 'channel2', 'channel3', 'channel4']:
        # å¸¦é€šæ»¤æ³¢ (4-8Hz Î¸æ³¢)
        b, a = signal.butter(4,  [4, 8], btype='bandpass', fs=self.sample_rate) 
        filtered = signal.filtfilt(b,  a, self.buffer[ch].values) 
        
        # è®¡ç®—åŠŸç‡è°±å¯†åº¦
        freqs, psd = signal.welch( 
            filtered, 
            fs=self.sample_rate,  
            nperseg=256 
        )
        
        # è®¡ç®—Î¸æ³¢åŠŸç‡å æ¯”
        theta_mask = (freqs >= 4) & (freqs <= 8)
        total_power = np.sum(psd) 
        theta_power = np.sum(psd[theta_mask]) 
        ratio = theta_power / total_power if total_power > 0 else 0 
        theta_power_ratios.append(ratio) 
    
    # å¹³å‡é€šé“å€¼ 
    avg_ratio = np.mean(theta_power_ratios) 
    
    # è§¦å‘ç–²åŠ³è­¦æŠ¥ 
    if avg_ratio > self.THETA_THRESHOLD:
        self.consecutive_count  = getattr(self, 'consecutive_count', 0) + 1
        
        if self.consecutive_count  >= self.CONSECUTIVE_COUNT:
            self._send_alert(avg_ratio)
            self.consecutive_count  = 0  # é‡ç½®è®¡æ•°å™¨
    else:
        self.consecutive_count  = 0 

def _send_alert(self, theta_ratio):
    """å‘ä¸»ç³»ç»Ÿå‘é€ç–²åŠ³è­¦æŠ¥"""
    alert_msg = f"FATIGUE_ALERT: theta_power={theta_ratio:.2f}"
    print(f"âš ï¸ {alert_msg}")
    
    try:
        self.sock.connect((self.host,  self.port)) 
        self.sock.sendall(alert_msg.encode('utf-8')) 
        self.sock.close() 
    except Exception as e:
        print(f"âŒ è­¦æŠ¥å‘é€å¤±è´¥: {str(e)}")

def visualize_spectrum(self, duration=5):
    """
    å¯è§†åŒ–EEGé¢‘è°±
    
    å‚æ•°:
    duration: åˆ†ææ—¶é•¿ (ç§’)
    """
    if not self.is_connected: 
        print("æœªè¿æ¥è®¾å¤‡")
        return
    
    plt.figure(figsize=(12,  8))
    
    # è·å–æœ€è¿‘Nç§’æ•°æ® 
    recent_data = self.buffer.tail(int(self.sample_rate  * duration))
    
    for i, ch in enumerate(['channel1', 'channel2', 'channel3', 'channel4'], 1):
        plt.subplot(2,  2, i)
        
        # è®¡ç®—PSD
        freqs, psd = signal.welch( 
            recent_data[ch], 
            fs=self.sample_rate,  
            nperseg=256
        )
        
        # ç»˜åˆ¶é¢‘è°± 
        plt.semilogy(freqs,  psd)
        plt.title(f' é€šé“ {i} åŠŸç‡è°±')
        plt.xlabel(' é¢‘ç‡ (Hz)')
        plt.ylabel(' åŠŸç‡è°±å¯†åº¦')
        plt.grid(True) 
        
        # æ ‡è®°Î¸æ³¢æ®µ 
        theta_band = (freqs >= 4) & (freqs <= 8)
        plt.fill_between(freqs[theta_band],  psd[theta_band], color='red', alpha=0.3)
    
    plt.tight_layout() 
    plt.show() 

def disconnect(self):
    """æ–­å¼€è®¾å¤‡è¿æ¥"""
    if self.is_connected: 
        self.stop_event.set() 
        if self.stream_thread: 
            self.stream_thread.join(timeout=2) 
        self.is_connected  = False
        print("ğŸ”Œ è®¾å¤‡å·²æ–­å¼€")

def __del__(self):
    self.disconnect() 